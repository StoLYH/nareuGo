# ====================================================================
# 1. 파이프라인 단계(Stages) 정의
# ====================================================================
# CI/CD 파이프라인은 여러 단계(Stage)로 구성됩니다.
# 여기서 정의한 순서대로 ('build' 실행 후 'deploy' 실행) 파이프라인이 진행됩니다.
stages:
  - build
  - deploy

# ====================================================================
# 2. 전역 변수(Variables) 정의
# ====================================================================
# 파이프라인 전체에서 공통으로 사용할 변수를 정의합니다.
variables:
  # 백엔드 Docker 이미지를 Docker Hub에 푸시할 때 사용할 이미지 이름입니다.
  # $DOCKERHUB_USERNAME은 GitLab CI/CD 설정에 등록한 변수입니다.
  DOCKER_IMAGE: $DOCKERHUB_USERNAME/a501

# ====================================================================
# 3. 백엔드 빌드 잡(Job)
# ====================================================================
# 역할: 백엔드 소스 코드를 Docker 이미지(실행 가능한 패키지)로 만드는 작업입니다.
build-backend:
  stage: build # 이 작업은 'build' 단계에 속합니다.
  image: gradle:7-jdk17 # Gradle과 Java 17이 설치된 Docker 환경에서 실행됩니다.
  tags: # 이 작업을 실행할 특정 GitLab Runner를 지정합니다.
    - ec2-runner
  script: # 실제로 실행될 명령어 목록입니다.
    - echo "====== [Backend] Gradle 빌드를 시작합니다. ======"
    - cd "NareuGO_Backend" # 백엔드 프로젝트 폴더로 이동합니다.
    - chmod +x ./gradlew # gradlew 스크립트에 실행 권한을 부여합니다.
    - ./gradlew clean build -x test # 테스트를 제외하고 프로젝트를 빌드합니다.
    - echo "====== [Backend] Docker 이미지를 빌드하고 푸시합니다. ======"
    - docker login -u "$DOCKERHUB_USERNAME" -p "$DOCKERHUB_TOKEN" # Docker Hub에 로그인합니다.
    - docker build --platform linux/amd64 -t $DOCKER_IMAGE:latest -f Dockerfile . # Dockerfile으로 이미지를 빌드합니다.
    - docker push $DOCKER_IMAGE:latest # 빌드된 이미지를 Docker Hub로 푸시합니다.
  rules: # 이 잡(Job)을 언제 실행할지 정의하는 규칙입니다.
    # master 브랜치에 있는 NareuGO_Backend 폴더 내의 파일이 변경되었을 때만 이 잡을 실행합니다.
    - if: '$CI_COMMIT_BRANCH == "master"'
      changes:
        - NareuGO_Backend/**/*

# ====================================================================
# 4. 프론트엔드 빌드 잡(Job)
# ====================================================================
# 역할: 프론트엔드 소스 코드를 웹서버가 이해할 수 있는 정적 파일(HTML, CSS 등)로 만드는 작업입니다.
build-frontend:
  stage: build # 이 작업은 'build' 단계에 속합니다. build-backend와 동시에 실행됩니다.
  image: node:18 # Node.js 18 버전이 설치된 Docker 환경에서 실행됩니다.
  tags:
    - ec2-runner
  script: # 실제로 실행될 명령어 목록입니다.
    - echo "====== [Frontend] Vue/React 빌드를 시작합니다. ======"
    - cd FrontEnd # 프론트엔드 프로젝트 폴더로 이동합니다.
    - npm install # 의존성 라이브러리를 설치합니다.
    - npm run build # Vue 프로젝트를 빌드하여 정적 파일(dist 폴더)을 생성합니다.
    - echo "====== [Frontend] 빌드 결과물(dist)을 artifacts로 저장합니다. ======"
  artifacts: # 잡(Job)의 결과물을 보관하는 기능입니다.
    paths:
      - FrontEnd/dist/ # 여기서 생성된 dist 폴더를 통째로 보관하여 다음 단계(deploy)로 전달합니다.
    expire_in: 1 hour # 보관된 파일은 1시간 후에 자동으로 삭제됩니다.
  rules: # 이 잡(Job)을 언제 실행할지 정의하는 규칙입니다.
    # master 브랜치에 있는 FrontEnd 폴더 내의 파일이 변경되었을 때만 이 잡을 실행합니다.
    - if: '$CI_COMMIT_BRANCH == "master"'
      changes:
        - FrontEnd/**/*

# ====================================================================
# 5. 배포 잡(Job)
# ====================================================================
# 역할: 빌드된 결과물을 실제 운영 서버에 옮기고, 서비스를 재시작하여 사용자에게 새 버전을 보여주는 작업입니다.
deploy:
  stage: deploy
  tags:
    - ec2-runner
  dependencies:
    - build-frontend
  before_script:
    - echo "====== [Deploy] 배포 환경 준비 (SSH/Curl/Rsync 설치) ======"
    - apt-get update -y && apt-get install -y openssh-client curl rsync
    - mkdir -p ~/.ssh
    - echo "$EC2_SSH_KEY" | tr -d '\r' > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - ssh-keyscan -H $LIVE_SERVER_IP >> ~/.ssh/known_hosts
  script:
    # --- 1. 프론트엔드 배포 ---
    - echo "====== 단계 1: 프론트엔드 파일 배포 시작 ======"
    - rsync -avz --delete ./FrontEnd/dist/ ubuntu@$LIVE_SERVER_IP:/var/www/html/
    - echo "✅ 프론트엔드 파일 배포 완료"

    # --- 2. 백엔드 무중단 배포 ---
    - echo "====== 단계 2: 백엔드 무중단 배포 시작 ======"
    - 'STATUS=$(curl -o /dev/null -w "%{http_code}" "http://$LIVE_SERVER_IP/env" || true)'
    - 'if [ "$STATUS" = "200" ]; then CURRENT_UPSTREAM=$(curl -s "http://$LIVE_SERVER_IP/env"); else CURRENT_UPSTREAM=green; fi'
    - 'echo "현재 upstream: $CURRENT_UPSTREAM"'
    - 'if [ "$CURRENT_UPSTREAM" = "blue" ]; then TARGET_UPSTREAM=green; STOPPED_PORT=8081; else TARGET_UPSTREAM=blue; STOPPED_PORT=8080; fi'
    - 'echo "배포 Target: $TARGET_UPSTREAM"'
    - 'ssh -o StrictHostKeyChecking=no ubuntu@$LIVE_SERVER_IP "sudo docker pull $DOCKER_IMAGE:latest && sudo docker-compose -f docker-compose-${TARGET_UPSTREAM}.yml up -d"'
    - 'echo "새 컨테이너 Health Check 시작..."'
    - 'RETRY=0; MAX_RETRY=30; until curl -s http://$LIVE_SERVER_IP:$STOPPED_PORT/env > /dev/null; do RETRY=$((RETRY+1)); if [ $RETRY -ge $MAX_RETRY ]; then echo "❌ Health Check 실패"; exit 1; fi; echo "⏳ 대기중... ($RETRY/$MAX_RETRY)"; sleep 10; done'
    - echo "✅ 새 컨테이너 Health Check 성공"
    - 'ssh -o StrictHostKeyChecking=no ubuntu@$LIVE_SERVER_IP "sudo docker exec -i nginxserver bash -c '\''echo \"set \$service_url ${TARGET_UPSTREAM};\" > /etc/nginx/conf.d/service-env.inc && nginx -s reload'\''"'
    - 'ssh -o StrictHostKeyChecking=no ubuntu@$LIVE_SERVER_IP "sudo docker stop ${CURRENT_UPSTREAM} || true && sudo docker rm ${CURRENT_UPSTREAM} || true"'
    - echo "====== ✅ 백엔드 무중단 배포 완료 ======"
  rules:
    - if: '$CI_COMMIT_BRANCH == "master"'
      changes:
        - NareuGO_Backend/**/*
        - FrontEnd/**/*
