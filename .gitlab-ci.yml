# ====================================================================
# 1. 파이프라인 단계(Stages) 정의
# ====================================================================
# CI/CD 파이프라인은 여러 단계(Stage)로 구성됩니다.
# 여기서 정의한 순서대로 ('build' 실행 후 'deploy' 실행) 파이프라인이 진행됩니다.
stages:
  - build
  - deploy

# ====================================================================
# 2. 전역 변수(Variables) 정의
# ====================================================================
# 파이프라인 전체에서 공통으로 사용할 변수를 정의합니다.
variables:
  # 백엔드 Docker 이미지를 Docker Hub에 푸시할 때 사용할 이미지 이름입니다.
  # $DOCKERHUB_USERNAME은 GitLab CI/CD 설정에 등록한 변수입니다.
  DOCKER_IMAGE: $DOCKERHUB_USERNAME/a501

# ====================================================================
# 3. 백엔드 빌드 잡(Job)
# ====================================================================
build-backend:
  stage: build # 이 작업은 'build' 단계에 속합니다.
  image: gradle:7-jdk11 # Gradle과 Java 11이 설치된 Docker 환경에서 실행됩니다.
  script: # 실제로 실행될 명령어 목록입니다.
    - cd "NareuGO_Backend" # 백엔드 프로젝트 폴더로 이동합니다.
    - chmod +x ./gradlew # gradlew 스크립트에 실행 권한을 부여합니다.
    - ./gradlew clean build -x test # 테스트를 제외하고 프로젝트를 빌드합니다.
    - docker login -u "$DOCKERHUB_USERNAME" -p "$DOCKERHUB_TOKEN" # Docker Hub에 로그인합니다.
    - docker build --platform linux/amd64 -t $DOCKER_IMAGE:latest -f Dockerfile . # Dockerfile으로 이미지를 빌드합니다.
    - docker push $DOCKER_IMAGE:latest # 빌드된 이미지를 Docker Hub로 푸시합니다.
  rules: # 이 잡(Job)을 언제 실행할지 정의하는 규칙입니다.
    # master 브랜치에 있는 NareuGO_Backend 폴더 내의 파일이 변경되었을 때만 이 잡을 실행합니다.
    - if: '$CI_COMMIT_BRANCH == "master"'
      changes:
        - NareuGO_Backend/**/*

# ====================================================================
# 4. 프론트엔드 빌드 잡(Job)
# ====================================================================
build-frontend:
  stage: build # 이 작업은 'build' 단계에 속합니다. build-backend와 동시에 실행됩니다.
  image: node:18 # Node.js 18 버전이 설치된 Docker 환경에서 실행됩니다.
  script: # 실제로 실행될 명령어 목록입니다.
    - cd FrontEnd # 프론트엔드 프로젝트 폴더로 이동합니다.
    - npm install # 의존성 라이브러리를 설치합니다.
    - npm run build # Vue/React 프로젝트를 빌드하여 정적 파일(dist 폴더)을 생성합니다.
  artifacts: # 잡(Job)의 결과물을 보관하는 기능입니다.
    paths:
      - FrontEnd/dist/ # 여기서 생성된 dist 폴더를 통째로 보관하여 다음 단계(deploy)로 전달합니다.
    expire_in: 1 hour # 보관된 파일은 1시간 후에 자동으로 삭제됩니다.
  rules: # 이 잡(Job)을 언제 실행할지 정의하는 규칙입니다.
    # master 브랜치에 있는 FrontEnd 폴더 내의 파일이 변경되었을 때만 이 잡을 실행합니다.
    - if: '$CI_COMMIT_BRANCH == "master"'
      changes:
        - FrontEnd/**/*

# ====================================================================
# 5. 배포 잡(Job)
# ====================================================================
deploy:
  stage: deploy # 이 작업은 'deploy' 단계에 속합니다. build 단계가 성공해야 실행됩니다.
  dependencies: # 다른 잡의 결과물(artifacts)을 가져와 사용하겠다는 의미입니다.
    - build-frontend # build-frontend 잡이 만든 dist 폴더를 사용하기 위해 명시합니다.
  before_script: # 메인 script가 실행되기 전에 항상 먼저 실행되는 명령어 목록입니다.
    - apt-get update -y && apt-get install -y openssh-client curl rsync # SSH, Curl, Rsync 도구를 설치합니다.
    - mkdir -p ~/.ssh # SSH 접속에 필요한 .ssh 폴더를 생성합니다.
    # GitLab 변수로 등록한 EC2_SSH_KEY(개인키) 내용을 id_rsa 파일로 만듭니다.
    - echo "$EC2_SSH_KEY" | tr -d '\r' > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa # 개인키 파일에 대한 접근 권한을 설정합니다. (필수)
    # 처음 접속하는 서버에 대한 경고 메시지를 비활성화하기 위해 서버의 공개키를 미리 등록합니다.
    - ssh-keyscan -H $LIVE_SERVER_IP >> ~/.ssh/known_hosts
  script: # 실제로 실행될 메인 명령어 목록입니다.
    # --- 프론트엔드 배포 ---
    - echo "Deploying frontend files..."
    # rsync를 이용해 build-frontend에서 받은 dist 폴더의 내용물을 EC2 서버의 /var/www/html/ 폴더로 복사합니다.
    - rsync -avz --delete -e "ssh -o StrictHostKeyChecking=no" ./FrontEnd/dist/ ubuntu@$LIVE_SERVER_IP:/var/www/html/

    # --- 백엔드 무중단 배포 ---
    - echo "Deploying backend application..."
    - |
      # 1. 현재 서비스 중인 서버(blue/green) 확인
      STATUS=$(curl -o /dev/null -w "%{http_code}" "http://$LIVE_SERVER_IP/env" || true)
      if [ "$STATUS" = "200" ]; then
        CURRENT_UPSTREAM=$(curl -s "http://$LIVE_SERVER_IP/env")
      else
        CURRENT_UPSTREAM=green # 최초 배포 시에는 green을 기본값으로
      fi
      echo "현재 upstream: $CURRENT_UPSTREAM"

      # 2. 다음 배포할 타겟 서버 결정
      if [ "$CURRENT_UPSTREAM" = "blue" ]; then
        TARGET_UPSTREAM=green
        STOPPED_PORT=8081
      else
        TARGET_UPSTREAM=blue
        STOPPED_PORT=8080
      fi

      # 3. 새 버전의 Docker 이미지 pull 받고, 새 컨테이너 실행
      ssh -o StrictHostKeyChecking=no ubuntu@$LIVE_SERVER_IP "
        sudo docker pull $DOCKER_IMAGE:latest &&
        sudo docker-compose -f docker-compose-${TARGET_UPSTREAM}.yml up -d
      "
      # 4. 새로 띄운 서버가 정상적으로 응답하는지 확인 (Health Check)
      curl --retry 15 --retry-delay 5 http://$LIVE_SERVER_IP:$STOPPED_PORT/env || exit 1

      # 5. Nginx가 새 컨테이너를 바라보도록 설정 변경 후 리로드
      ssh -o StrictHostKeyChecking=no ubuntu@$LIVE_SERVER_IP "
        sudo docker exec -i nginxserver bash -c 'echo \"set \\\$service_url ${TARGET_UPSTREAM};\" > /etc/nginx/conf.d/service-env.inc && nginx -s reload'
      "

      # 6. 이전 버전의 컨테이너 중지 및 삭제
      ssh -o StrictHostKeyChecking=no ubuntu@$LIVE_SERVER_IP "
        sudo docker stop ${CURRENT_UPSTREAM} && sudo docker rm ${CURRENT_UPSTREAM}
      "
  rules: # 이 잡(Job)을 언제 실행할지 정의하는 규칙입니다.
    # master 브랜치에 있는 백엔드 또는 프론트엔드 폴더 내의 파일이 변경되었을 때만 이 잡을 실행합니다.
    - if: '$CI_COMMIT_BRANCH == "master"'
      changes:
        - NareuGO_Backend/**/*
        - FrontEnd/**/*
