# ====================================================================
# 1. 파이프라인 단계(Stages) 정의
# ====================================================================
# CI/CD 파이프라인은 여러 단계(Stage)로 구성됩니다.
# 여기서 정의한 순서대로 ('build' 실행 후 'deploy' 실행) 파이프라인이 진행됩니다.
stages:
  - build
  - deploy

# ====================================================================
# 2. 전역 변수(Variables) 정의
# ====================================================================
# 파이프라인 전체에서 공통으로 사용할 변수를 정의합니다.
variables:
  # 백엔드 Docker 이미지를 Docker Hub에 푸시할 때 사용할 이미지 이름입니다.
  # $DOCKERHUB_USERNAME은 GitLab CI/CD 설정에 등록한 변수입니다.
  DOCKER_IMAGE: $DOCKERHUB_USERNAME/a501

# ====================================================================
# 3. 백엔드 빌드 잡(Job)
# ====================================================================
# 역할: 백엔드 소스 코드를 Docker 이미지(실행 가능한 패키지)로 만드는 작업입니다.
build-backend:
  stage: build # 이 작업은 'build' 단계에 속합니다.
  image: gradle:7-jdk17 # Gradle과 Java 17이 설치된 Docker 환경에서 실행됩니다.
  tags: # 이 작업을 실행할 특정 GitLab Runner를 지정합니다.
    - ec2-runner
  script: # 실제로 실행될 명령어 목록입니다.
    - echo "====== [Backend] Gradle 빌드를 시작합니다. ======"
    - cd "NareuGO_Backend" # 백엔드 프로젝트 폴더로 이동합니다.
    - chmod +x ./gradlew # gradlew 스크립트에 실행 권한을 부여합니다.
    - ./gradlew clean build -x test # 테스트를 제외하고 프로젝트를 빌드합니다.
    - echo "====== [Backend] Docker 이미지를 빌드하고 푸시합니다. ======"
    - docker login -u "$DOCKERHUB_USERNAME" -p "$DOCKERHUB_TOKEN" # Docker Hub에 로그인합니다.
    - docker build --platform linux/amd64 -t $DOCKER_IMAGE:latest -f Dockerfile . # Dockerfile으로 이미지를 빌드합니다.
    - docker push $DOCKER_IMAGE:latest # 빌드된 이미지를 Docker Hub로 푸시합니다.
  rules: # 이 잡(Job)을 언제 실행할지 정의하는 규칙입니다.
    # master 브랜치에 있는 NareuGO_Backend 폴더 내의 파일이 변경되었을 때만 이 잡을 실행합니다.
    - if: '$CI_COMMIT_BRANCH == "master"'
      changes:
        - NareuGO_Backend/**/*

# ====================================================================
# 4. 프론트엔드 빌드 잡(Job)
# ====================================================================
# 역할: 프론트엔드 소스 코드를 웹서버가 이해할 수 있는 정적 파일(HTML, CSS 등)로 만드는 작업입니다.
build-frontend:
  stage: build # 이 작업은 'build' 단계에 속합니다. build-backend와 동시에 실행됩니다.
  image: node:18 # Node.js 18 버전이 설치된 Docker 환경에서 실행됩니다.
  tags:
    - ec2-runner
  script: # 실제로 실행될 명령어 목록입니다.
    - echo "====== [Frontend] Vue/React 빌드를 시작합니다. ======"
    - cd FrontEnd # 프론트엔드 프로젝트 폴더로 이동합니다.
    - npm install # 의존성 라이브러리를 설치합니다.
    - npm run build # Vue 프로젝트를 빌드하여 정적 파일(dist 폴더)을 생성합니다.
    - echo "====== [Frontend] 빌드 결과물(dist)을 artifacts로 저장합니다. ======"
  artifacts: # 잡(Job)의 결과물을 보관하는 기능입니다.
    paths:
      - FrontEnd/dist/ # 여기서 생성된 dist 폴더를 통째로 보관하여 다음 단계(deploy)로 전달합니다.
    expire_in: 1 hour # 보관된 파일은 1시간 후에 자동으로 삭제됩니다.
  rules: # 이 잡(Job)을 언제 실행할지 정의하는 규칙입니다.
    # master 브랜치에 있는 FrontEnd 폴더 내의 파일이 변경되었을 때만 이 잡을 실행합니다.
    - if: '$CI_COMMIT_BRANCH == "master"'
      changes:
        - FrontEnd/**/*

# ====================================================================
# 5. 배포 잡(Job)
# ====================================================================
# 역할: 빌드된 결과물을 실제 운영 서버에 옮기고, 서비스를 재시작하여 사용자에게 새 버전을 보여주는 작업입니다.
deploy:
  stage: deploy # 이 작업은 'deploy' 단계에 속합니다. build 단계가 성공해야 실행됩니다.
  tags:
    - ec2-runner
  dependencies: # 다른 잡의 결과물(artifacts)을 가져와 사용하겠다는 의미입니다.
    - build-frontend # build-frontend 잡이 만든 dist 폴더를 사용하기 위해 명시합니다.
  before_script: # 메인 script가 실행되기 전에 항상 먼저 실행되는 명령어 목록입니다.
    - echo "====== [Deploy] 배포 환경을 준비합니다. (패키지 설치 및 SSH 설정) ======"
    - apt-get update -y && apt-get install -y openssh-client curl rsync # SSH, Curl, Rsync 도구를 설치합니다.
    - mkdir -p ~/.ssh # SSH 접속에 필요한 .ssh 폴더를 생성합니다.
    # GitLab 변수로 등록한 EC2_SSH_KEY(개인키) 내용을 id_rsa 파일로 만듭니다.
    - echo "$EC2_SSH_KEY" | tr -d '\r' > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa # 개인키 파일에 대한 접근 권한을 설정합니다. (필수)
    # 처음 접속하는 서버에 대한 경고 메시지를 비활성화하기 위해 서버의 공개키를 미리 등록합니다.
    - ssh-keyscan -H $LIVE_SERVER_IP >> ~/.ssh/known_hosts
  script: # 실제로 실행될 메인 명령어 목록입니다.
    # --- 1. 프론트엔드 배포 ---
    - echo "====== 단계 1: 프론트엔드 파일 배포 시작 ======"
    # rsync를 이용해 build-frontend에서 받은 dist 폴더의 내용물을 EC2 서버의 /var/www/html/ 폴더로 복사합니다.
    - rsync -avz --delete ./FrontEnd/dist/ ubuntu@$LIVE_SERVER_IP:/var/www/html/
    - echo "✅ 프론트엔드 파일 배포 완료"

    # --- 2. 백엔드 무중단 배포 ---
    # | 기호는 여러 줄의 명령어를 하나의 스크립트 블록으로 묶어줍니다.
    - |
      echo "====== 단계 2: 백엔드 무중단 배포 시작 ======"

      echo "--> 2-1. 현재 운영 중인 upstream 확인..."
      # /env 엔드포인트를 호출하여 현재 서비스 중인 서버(blue/green)가 무엇인지 확인합니다.
      STATUS=$(curl -o /dev/null -w "%{http_code}" "http://$LIVE_SERVER_IP/env" || true)
      if [ "$STATUS" = "200" ]; then
        CURRENT_UPSTREAM=$(curl -s "http://$LIVE_SERVER_IP/env")
      else
        CURRENT_UPSTREAM=green # 최초 배포 시에는 green을 기본값으로 설정합니다.
      fi
      echo "    현재 upstream: $CURRENT_UPSTREAM"

      echo "--> 2-2. 배포할 Target upstream 결정..."
      # 현재 운영 서버에 따라 다음 배포할 서버(Target)를 결정합니다.
      if [ "$CURRENT_UPSTREAM" = "blue" ]; then
        TARGET_UPSTREAM=green
        STOPPED_PORT=8081
      else
        TARGET_UPSTREAM=blue
        STOPPED_PORT=8080
      fi
      echo "    배포 Target: $TARGET_UPSTREAM"

      echo "--> 2-3. 새 Docker 컨테이너 실행..."
      # SSH로 서버에 접속하여, 새 버전의 Docker 이미지를 받고 Target 서버용 docker-compose를 실행합니다.
      ssh -o StrictHostKeyChecking=no ubuntu@$LIVE_SERVER_IP "
        sudo docker pull $DOCKER_IMAGE:latest &&
        sudo docker-compose -f docker-compose-${TARGET_UPSTREAM}.yml up -d
      "

      echo "--> 2-4. 새 컨테이너 Health Check 시작 (최대 5분 대기)..."
      # 새로 띄운 서버가 정상적으로 응답할 때까지 기다립니다. (Spring Boot 기동 시간 확보)
      sleep 40 
      MAX_RETRY=30
      RETRY_COUNT=0
      until curl -s http://$LIVE_SERVER_IP:$STOPPED_PORT/env > /dev/null; do
        RETRY_COUNT=$((RETRY_COUNT+1))
        if [ $RETRY_COUNT -ge $MAX_RETRY ]; then
          echo "    ❌ 새 컨테이너 Health Check 실패"
          exit 1
        fi
        echo "    ⏳ 컨테이너 기동 대기중... (${RETRY_COUNT}/${MAX_RETRY})"
        sleep 10
      done
      echo "    ✅ 새 컨테이너 Health Check 성공"

      echo "--> 2-5. Nginx 경로를 새 upstream으로 전환..."
      # Health Check 성공 시, Nginx가 새로운 Target 서버를 바라보도록 설정을 변경하고 리로드합니다.
      ssh -o StrictHostKeyChecking=no ubuntu@$LIVE_SERVER_IP "
        sudo docker exec -i nginxserver bash -c 'echo \"set \\\$service_url ${TARGET_UPSTREAM};\" > /etc/nginx/conf.d/service-env.inc && nginx -s reload'
      "

      echo "--> 2-6. 이전 upstream 컨테이너 종료 및 삭제..."
      # 이제 아무도 사용하지 않는 이전 버전의 컨테이너를 중지하고 삭제합니다.
      ssh -o StrictHostKeyChecking=no ubuntu@$LIVE_SERVER_IP "
        sudo docker stop ${CURRENT_UPSTREAM} || true &&
        sudo docker rm ${CURRENT_UPSTREAM} || true
      "

      echo "====== ✅ 백엔드 무중단 배포 완료 ======"
  rules: # 이 잡(Job)을 언제 실행할지 정의하는 규칙입니다.
    # master 브랜치에 있는 백엔드 또는 프론트엔드 폴더 내의 파일이 변경되었을 때만 이 잡을 실행합니다.
    - if: '$CI_COMMIT_BRANCH == "master"'
      changes:
        - NareuGO_Backend/**/*
        - FrontEnd/**/*
